<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>vmware-cloud-director-ui-components documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top d-block d-sm-none">
            <a href="../" class="navbar-brand">vmware-cloud-director-ui-components documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  QuickSearchFilterOption</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/components/src/quick-search/quick-search.service.ts</code>
        </p>


            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Represents a possible selection option for a filter.</p>

            </p>


        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#data" 
>
                                            data
                                        </a>
                                </li>
                                <li>
                                        <a href="#display" 
>
                                            display
                                        </a>
                                </li>
                                <li>
                                        <a href="#key" 
>
                                            key
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="data"></a>
                                        <span class="name "><b>data</b>
                                            <a href="#data">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>data:         <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Any optional data that is associated with this option.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="display"></a>
                                        <span class="name "><b>display</b>
                                            <a href="#display">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>display:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>The displayed title of this option.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="key"></a>
                                        <span class="name "><b>key</b>
                                            <a href="#key">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>key:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>The key of this quick search filter option.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Injectable } from &#x27;@angular/core&#x27;;
import { ReplaySubject } from &#x27;rxjs&#x27;;
import { QuickSearchNestedProvider, QuickSearchProvider } from &#x27;./quick-search.provider&#x27;;
import { QuickSearchResults } from &#x27;.&#x27;;

/**
 * A group of search sections.
 */
export interface GroupedSearchSections {
    /**
     * The i18n key for the header.
     */
    headerTitle: string;
    /**
     * All of the sections within this section.
     */
    subSections: SearchSection[];
}

export interface SearchSection {
    provider: QuickSearchProvider;
    result: QuickSearchResults;
    isLoading: boolean;
    shouldShowText: boolean;
    hasPartialResult: PartialResult;
    icon?: string;
}

/**
 * A filter that can be applied to quick search to filter results.
 */
export interface QuickSearchFilter {
    /**
     * The unique ID of this filter.
     */
    id: string;
    /**
     * The options that are displayed in the dropdown.
     */
    options: QuickSearchFilterOption[];
    /**
     * The text displayed on the button to open the dropdown.
     */
    dropdownText: string;
    /**
     * The i18n key for the selection bubble of this filter. Is passed one parameter {display} which is the value selected.
     */
    bubbleI18nKey: string;
    /**
     * The order of the filter when displaying the filters. The lower the order, the closer to the beginning.
     * undefined and -1 means append
     */
    order?: number;
}

/**
 * Represents a possible selection option for a filter.
 */
export interface QuickSearchFilterOption {
    /**
     * The displayed title of this option.
     */
    display: string;

    /**
     * The key of this quick search filter option.
     */
    key: string;
    /**
     * Any optional data that is associated with this option.
     */
    data?: any;
}

/**
 * A filter that has a value typed in.
 */
export interface ActiveQuickSearchFilter extends QuickSearchFilter {
    /**
     * The key value of the selected option.
     */
    value: string;
    /**
     * Any date assocated with this filter option.
     */
    data: any;
}

/**
 * This interface describes partial search result, i.e. result that do not contain all the items that match the
 * search criteria {@see QuickSearchComponent#hasPartialResult}
 */
export interface PartialResult {
    /**
     * The number of the last item of the result
     */
    lastItem: number;

    /**
     * Total number of items in the result
     */
    totalItems: number;
}

@Injectable({
    providedIn: &#x27;root&#x27;,
})
export class QuickSearchService {
    private registrations: QuickSearchProvider[] &#x3D; [];
    private nestedProviders: QuickSearchNestedProvider[] &#x3D; [];

    private searchId &#x3D; 0;

    private filterValues: Map&lt;string, QuickSearchFilterOption[]&gt; &#x3D; new Map();

    /**
     * The filters the last search was run with.
     */
    private lastActiveFilters: ActiveQuickSearchFilter[] &#x3D; [];
    /**
     * The term the last search was run with.
     */
    private lastSearchCriteria: string &#x3D; &#x27;&#x27;;

    /**
     * The search sections are provided by the {@link QuickSearchService} upon opening the Quick Search.
     * This insures that new sections based on the current context of the application may appear.
     *
     * The groupedSearchSections are sections that come from Nested providers and are a double deep list of results with
     * a parent section name, and sub section names.
     *
     * The ungroupedSearchSections are sections that come from Search providers and are a single list of results with a section name.
     *
     * These two events emit when anything about the search sections changes.
     */
    public groupedSearchSectionChanged: ReplaySubject&lt;GroupedSearchSections[]&gt; &#x3D; new ReplaySubject&lt;
        GroupedSearchSections[]
    &gt;();
    public ungroupedSearchSectionChanged: ReplaySubject&lt;SearchSection[]&gt; &#x3D; new ReplaySubject&lt;SearchSection[]&gt;();

    private _groupedSearchSections: GroupedSearchSections[] &#x3D; [];
    private _ungroupedSearchSections: SearchSection[] &#x3D; [];

    /**
     * Emits a value when any information about the filter selection changes.
     */
    public filterValueChanges: ReplaySubject&lt;Map&lt;string, QuickSearchFilterOption[]&gt;&gt; &#x3D; new ReplaySubject&lt;
        Map&lt;string, QuickSearchFilterOption[]&gt;
    &gt;();

    /**
     * The current set of registered filters.
     */
    public filters: QuickSearchFilter[] &#x3D; [];

    /**
     * If the quick search modal is pinned.
     */
    public isPinned: boolean &#x3D; false;

    /**
     * If any section is loading.
     */
    public isLoading: boolean &#x3D; false;

    /**
     * If all sections return no results.
     */
    public hasNoResults: boolean &#x3D; false;

    /**
     * Register a search provider
     * @param provider The search provider {@link QuickSearchProvider}
     */
    public registerProvider(provider: QuickSearchProvider): void {
        insertInOrder(provider, this.registrations);
        this.updateActiveSections(this.lastActiveFilters);
    }

    /**
     * Unregister a search provider by providing the registration id.
     * Returns true if un-registration was done.
     * @param provider Provider to be unregistered
     */
    public unregisterProvider(provider: QuickSearchProvider): boolean {
        const index &#x3D; this.registrations.findIndex((regProvider) &#x3D;&gt; regProvider &#x3D;&#x3D;&#x3D; provider);
        if (index &gt; -1) {
            this.registrations.splice(index, 1);
        }
        return index &gt; -1;
    }

    /**
     * Registers a nested provider to search for results in quick search.
     */
    public registerNestedProvider(nestedProvider: QuickSearchNestedProvider) {
        insertInOrder(nestedProvider, this.nestedProviders);
        this.updateActiveSections(this.lastActiveFilters);
    }

    public unregisterNestedProvider(nestedProvider: QuickSearchNestedProvider) {
        const index &#x3D; this.nestedProviders.findIndex((regProvider) &#x3D;&gt; regProvider &#x3D;&#x3D;&#x3D; nestedProvider);
        if (index &gt; -1) {
            this.nestedProviders.splice(index, 1);
        }
        return index &gt; -1;
    }

    /**
     * Get a list of all the registered search providers.
     */
    public getRegisteredProviders(filters?: ActiveQuickSearchFilter[]): QuickSearchProvider[] {
        if (!filters || !filters.length) {
            return [...this.registrations];
        }
        return this.registrations.filter((searchProvider) &#x3D;&gt; this.providerShouldBeActive(searchProvider, filters));
    }

    /**
     * Gives the list of currently active providers given the set of filters.
     */
    public getRegisteredNestedProviders(filters?: ActiveQuickSearchFilter[]): QuickSearchNestedProvider[] {
        if (!filters || !filters.length) {
            return [...this.nestedProviders];
        }
        const newNestedProviders: QuickSearchNestedProvider[] &#x3D; this.nestedProviders.map((nestedProvider) &#x3D;&gt; {
            return {
                order: nestedProvider.order,
                sectionName: nestedProvider.sectionName,
                children: nestedProvider.children.filter((provider) &#x3D;&gt; this.providerShouldBeActive(provider, filters)),
            };
        });
        return newNestedProviders.filter((provider) &#x3D;&gt; provider.children.length);
    }

    /**
     * Adds a filter to the list of registered filters. A filter can be used to filter the list of providers and/or the results from a given provider.
     *
     * All filters have some ID that is displayed and a list of options for their value. These options can also have associated data.
     *
     * A provider then must know
     * 1. If it can respond to a given filter&lt;/li&gt;
     * 2. How to filter the search results given the filter&lt;/li&gt;
     *
     * This means that if Filter A is present, and Provider 1 cannot respond to it, Provider 1 will not be displayed. Provider 2 must
     * then filter its results based on the filter.
     *
     * If two filters of different IDs are used in the search, the filters should act like and&#x27;s. If two filters of the same ID
     * are present in the search, the filter should act like an or.
     */
    public registerFilter(filter: QuickSearchFilter) {
        insertInOrder(filter, this.filters);
    }

    /**
     * Removes the given filterId from the list of registered filters.
     */
    public unregisterFilter(filterId: string) {
        this.filters &#x3D; this.filters.filter((filter) &#x3D;&gt; filter.id !&#x3D;&#x3D; filterId);
    }

    /**
     * Selects the given filterValue on the filter represented by the given filterId.
     *
     * @param clear clears the selection before setting if set to true, and defaults to true.
     *
     * @example selectFilter(&#x27;type&#x27;, &#x27;org&#x27;) selects the Organization option in the &quot;Type&quot; filter.
     */
    public selectFilter(filterId: string, filterValues: string[], clear: boolean &#x3D; true): void {
        const foundFilter &#x3D; this.filters.find((filter) &#x3D;&gt; filter.id &#x3D;&#x3D;&#x3D; filterId);
        if (!foundFilter) {
            return;
        }

        if (clear) {
            this.filterValues.set(filterId, []);
        }

        for (const optionKey of filterValues.filter(Boolean)) {
            const foundOption &#x3D; foundFilter.options.find((option) &#x3D;&gt; option.key &#x3D;&#x3D;&#x3D; optionKey);

            if (foundOption &#x3D;&#x3D;&#x3D; undefined) {
                continue;
            }
            const isActive &#x3D; this.getFilterOptionValue(filterId, optionKey);
            if (isActive) {
                this.filterValues.set(
                    filterId,
                    this.getFilterValue(filterId).filter((option) &#x3D;&gt; option.key !&#x3D;&#x3D; optionKey)
                );
            } else {
                this.getFilterValue(filterId).push(foundOption);
            }
        }

        this.filterValueChanges.next(this.filterValues);
        this.doSearch(this.lastSearchCriteria);
    }

    /**
     * Searches all the providers given the search term and the active filters.
     *
     * @param force runs the search even if the active filters and search term has not changed.
     */
    public doSearch(searchCriteria: string, force?: boolean, afterSectionLoad?: () &#x3D;&gt; void): Promise&lt;SearchSection[]&gt; {
        const activeFilters &#x3D; this.buildActiveFilters();

        // If the active filters are the same as last time and the search term has not changed
        // We should not run a search unless force is true.
        if (
            this.lastActiveFilters.length &#x3D;&#x3D;&#x3D; activeFilters.length &amp;&amp;
            searchCriteria &#x3D;&#x3D;&#x3D; this.lastSearchCriteria &amp;&amp;
            !force
        ) {
            return;
        }
        this.lastActiveFilters &#x3D; activeFilters;
        this.lastSearchCriteria &#x3D; searchCriteria;
        this.updateActiveSections(activeFilters);

        // Remember which is the current search. This will help us not to show results from an old search
        const searchId &#x3D; ++this.searchId;

        // Mark each sections in loading state. This flag is needed when trying to select the first item
        // while the search is still in progress
        const flatSections &#x3D; this.getFlattenedSearchSections();

        if (flatSections.length &#x3D;&#x3D;&#x3D; 0) {
            return;
        }

        this.isLoading &#x3D; true;
        flatSections.forEach((searchSection) &#x3D;&gt; (searchSection.isLoading &#x3D; true));

        // Go through the available search sections, i.e. the registered search providers and request for results
        return Promise.all(
            flatSections.map(async (searchSection) &#x3D;&gt; {
                let searchResult: QuickSearchResults;
                // Only request for data if the search is not empty
                if (searchCriteria &amp;&amp; searchCriteria.length &gt; 0) {
                    const result &#x3D; searchSection.provider.search(searchCriteria, activeFilters);

                    // Some of the results may be provided later, so mark the section as loading
                    if (result instanceof Promise) {
                        searchResult &#x3D; await result;
                    } else {
                        searchResult &#x3D; result;
                    }
                    // Use the closure to verify that the displayed data is going to be really from the latest search
                    if (searchId !&#x3D;&#x3D; this.searchId) {
                        return;
                    }
                }

                // This code will get called for each of the key strokes that gets typed during the buffer time. This means if there were 10
                // characters typed during the de-bouncing time, this code will be called 10 times after the promise is resolved from a provider
                // search function. However, we don&#x27;t currently see any problem with that because the following code just re assigns variables
                // with same values
                searchSection.result &#x3D; searchResult;
                searchSection.hasPartialResult &#x3D; this.hasPartialResult(searchSection);
                searchSection.isLoading &#x3D; false;
                this.hasNoResults &#x3D; this.checkHasNoResults();
                searchSection.shouldShowText &#x3D; this.showSectionTitle(searchSection);

                if (afterSectionLoad) {
                    afterSectionLoad();
                }
                this.groupedSearchSectionChanged.next([...this._groupedSearchSections]);
                this.ungroupedSearchSectionChanged.next([...this._ungroupedSearchSections]);

                return searchSection;
            })
        ).finally(() &#x3D;&gt; {
            if (searchId &#x3D;&#x3D;&#x3D; this.searchId) {
                this.isLoading &#x3D; false;
            }
        });
    }

    /**
     * Builds an array of the currently active quick search filters.
     */
    private buildActiveFilters(): ActiveQuickSearchFilter[] {
        const activeFilters: ActiveQuickSearchFilter[] &#x3D; [];
        this.filterValues.forEach((valueList, id) &#x3D;&gt; {
            valueList.forEach((value) &#x3D;&gt; {
                activeFilters.push({
                    id,
                    value: value.key,
                    data: value.data,
                } as ActiveQuickSearchFilter);
            });
        });

        return activeFilters;
    }

    /**
     * Updates the active search providers based on the active filters.
     */
    private updateActiveSections(activeFilters: ActiveQuickSearchFilter[]) {
        this._ungroupedSearchSections &#x3D; this.getRegisteredProviders(activeFilters).map((provider) &#x3D;&gt; ({
            provider,
            result: null,
            isLoading: true,
            shouldShowText: false,
            hasPartialResult: undefined,
            icon: provider.icon,
        }));
        this._groupedSearchSections &#x3D; this.getRegisteredNestedProviders(activeFilters).map((section) &#x3D;&gt; {
            return {
                headerTitle: section.sectionName,
                subSections: section.children.map((provider) &#x3D;&gt; ({
                    provider,
                    result: null,
                    isLoading: true,
                    shouldShowText: false,
                    hasPartialResult: undefined,
                    icon: provider.icon,
                })),
            };
        });

        this.groupedSearchSectionChanged.next(this._groupedSearchSections);
        this.ungroupedSearchSectionChanged.next(this._ungroupedSearchSections);
    }

    /**
     * Gives whether the given option on the given filter is selected.
     */
    private getFilterOptionValue(filterId: string, optionKey: string): boolean {
        return !!this.getFilterValue(filterId).find((option) &#x3D;&gt; option.key &#x3D;&#x3D;&#x3D; optionKey);
    }

    /**
     * Gives all the options selected for the given filter.
     */
    private getFilterValue(filterId: string): QuickSearchFilterOption[] {
        if (!this.filterValues.get(filterId)) {
            this.filterValues.set(filterId, []);
        }
        return this.filterValues.get(filterId);
    }

    /**
     * Gives the search sections as a single flat list.
     */
    private getFlattenedSearchSections(): SearchSection[] {
        const allSections: SearchSection[] &#x3D; [];
        // Takes the nested providers, and turns them to a single deep list of sections.
        this._groupedSearchSections.forEach((section) &#x3D;&gt; allSections.push(...section.subSections));
        return [...this._ungroupedSearchSections, ...allSections];
    }

    /**
     * Says if the given provider should be active given the filters selected.
     */
    private providerShouldBeActive(provider: QuickSearchProvider, filters: ActiveQuickSearchFilter[]): boolean {
        const filtersGrouped &#x3D; new Map&lt;string, ActiveQuickSearchFilter[]&gt;();
        filters.forEach((filter) &#x3D;&gt; {
            const current &#x3D; filtersGrouped.get(filter.id);
            if (current) {
                current.push(filter);
            } else {
                filtersGrouped.set(filter.id, [filter]);
            }
        });

        return Array.from(filtersGrouped.keys()).every((key) &#x3D;&gt;
            filtersGrouped.get(key).some((filter) &#x3D;&gt; provider.canHandleFilter &amp;&amp; provider.canHandleFilter(filter))
        );
    }

    /**
     * Determines if the result in this section is partial (i.e. there are more items matching the criteria which are
     * in the current list) or it is full (the current list contains all the items matching the criteria)
     * If the result is partial then {@link PartialResult} object is returned. If the result contains all the items
     * then null is returned
     * @param searchSection the section which result items is to be checked
     */
    private hasPartialResult(searchSection: SearchSection): PartialResult {
        if (
            searchSection.result?.total &amp;&amp;
            searchSection.result?.items?.length &amp;&amp;
            searchSection.result.items.length &lt; searchSection.result.total
        ) {
            return {
                lastItem: searchSection.result.items.length,
                totalItems: searchSection.result.total,
            };
        }
        return null;
    }

    /**
     * Says if the title of the given search section should be shown.
     */
    private showSectionTitle(searchSection: SearchSection): boolean {
        // Do not show when there is no section name
        if (!searchSection.provider.sectionName) {
            return false;
        }

        // Don&#x27;t show when it is loading
        if (searchSection.isLoading) {
            return false;
        }

        // Do not show when the provider has no results
        if (!searchSection.result?.items?.length) {
            return false;
        }

        return true;
    }

    /**
     * Says if all providers have returned no results.
     */
    private checkHasNoResults(): boolean {
        return this.getFlattenedSearchSections().every((section) &#x3D;&gt; section.result?.items?.length &#x3D;&#x3D;&#x3D; 0);
    }
}

const insertInOrder &#x3D; (item: { order?: number }, orderedArray: { order?: number }[]): void &#x3D;&gt; {
    const order &#x3D; typeof item.order &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; ? -1 : item.order;

    let insertIndex &#x3D; -1;
    // Determine the position of the new registration
    if (order &gt; -1) {
        insertIndex &#x3D; orderedArray.findIndex((fltr) &#x3D;&gt; {
            // If an item has a negative index, this means no order had been provided for that item,
            // this means we have found the insert index
            if (fltr.order &lt; 0 || typeof fltr.order &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
                return true;
            }

            // If an item has a bigger order than the new one,
            // this means we have found the insert index
            if (order &lt; fltr.order) {
                return true;
            }
        });
    }

    if (insertIndex &gt; -1) {
        orderedArray.splice(insertIndex, 0, item);
    } else {
        orderedArray.push(item);
    }
};
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'QuickSearchFilterOption.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
