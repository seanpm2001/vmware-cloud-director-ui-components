<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>vmware-cloud-director-ui-components documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top d-block d-sm-none">
            <a href="../" class="navbar-brand">vmware-cloud-director-ui-components documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  HasFinder</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/components/src/utils/test/widget-object.ts</code>
        </p>


            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Can be used in tests that use <code>this</code> to share a finder with before/AfterEach instead of leaky closures</p>

            </p>


        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#finder" 
>
                                            finder
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="finder"></a>
                                        <span class="name "><b>finder</b>
                                            <a href="#finder">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>finder:         <code><a href="../classess/WidgetFinder.html" target="_self" >WidgetFinder&lt;T&gt;</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../classess/WidgetFinder.html" target="_self" >WidgetFinder&lt;T&gt;</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { DebugElement, Type } from &#x27;@angular/core&#x27;;
import { ComponentFixture, TestBed } from &#x27;@angular/core/testing&#x27;;
import { By } from &#x27;@angular/platform-browser&#x27;;

/**
 * An implementation of the page object pattern, but applied to widgets, since they can be reused on multiple pages.
 *
 * The main purpose for the wrapper are providing access to the internals of a widget avoiding duplication of code that
 * queries the internals of a component from a test.
 *
 * ## Subclass Rules
 *
 * - Methods exposed by subclasses should not expose HTMLElements or DebugElements directly. That would encourage
 * callers to query it from the outside creating potential duplicate querying code and abstraction leaks.
 *  - Subclasses also should not have testing assertions. They should only provide the state and the calling test can
 * assert code on its own.
 *
 * &#x60;T&#x60; is the type of the JS/TS object being wrapped
 *
 * It is recommended that files for implementations be named with a &#x60;.wo.ts&#x60; extension
 *
 * @deprecated
 */
export abstract class WidgetObject&lt;T&gt; {
    /**
     *
     * Constructor should only be called directly if you are directly instantiating the widget being wrapped (T). If you
     * need to find a widget within the tree, you should use {@link find}.
     *
     * @param component The component instance being managed. Whenever possible, we should access the component&#x27;s API.
     * @param root The root element (host) for the component instance. We typically prefer to interact with the
     * component but there are times when we must check the DOM.
     * @param fixture The test fixture, so we can call {@link ComponentFixture#detectChanges} after something that
     * requires re-rendering of the DOM.
     */
    constructor(
        protected fixture: ComponentFixture&lt;any&gt;,
        protected root: DebugElement &#x3D; fixture.debugElement,
        public component: T &#x3D; fixture.componentInstance
    ) {}

    detectChanges(): void {
        this.fixture.detectChanges();
    }

    /**
     * Finds first element within this widget matching the given selector
     * @param selector What to search for
     * @param parent Where to start the search; defaults to the root of this component
     */
    protected findElement(selector: string | Type&lt;unknown&gt;, parent: DebugElement &#x3D; this.root): DebugElement {
        const query &#x3D; typeof selector &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? By.css(selector) : By.directive(selector);
        return parent.query(query);
    }

    /**
     * Same as {@link findElement} but returns all elements
     */
    protected findElements(selector: string | Type&lt;unknown&gt;, parent: DebugElement &#x3D; this.root): DebugElement[] {
        const query &#x3D; typeof selector &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? By.css(selector) : By.directive(selector);
        return parent.queryAll(query);
    }

    /**
     * Clicks an element and detects changes so the DOM is immediately updated
     * @param cssSelector Pass this in if you want to click a specific element. If not passed in, the entire node will
     * receive the click event
     * @param parent the parent element for which to search for the {@param cssSelector} within. Defaults to root if not provided.
     */
    protected click(cssSelector?: string, parent: DebugElement &#x3D; this.root): void {
        const nativeElement: HTMLBaseElement &#x3D; parent.query(By.css(cssSelector)).nativeElement;
        nativeElement.click();
        this.detectChanges();
    }

    /**
     * Send a keyboard event of type {@param eventType} with properties {@param eventProperties} on an element
     * found by the {@param cssSelector} within the provided {@param parent} or the current root element.
     * Setting the event properties is done with &#x60;Object.defineProperty&#x60; on the created event. This allows setting
     * properties like &#x60;which&#x60; that is deprecated and cannot be set with the native approach of creating keyboard event.
     * @param eventType The keyboard event type like &#x27;keyup&#x27;, &#x27;keydown&#x27;, &#x27;keypress&#x27;
     * @param eventProperties properties of the event like &#x60;code&#x60;, &#x60;key&#x60; etc.
     * @param cssSelector Pass this in if you want trigger the event on a specific element.
     *        If not passed in, the event will be triggered on the entire node
     * @param parent the parent element for which to search for the {@param cssSelector} within. Defaults to root if not provided.
     */
    protected sendKeyboardEvent(
        eventType,
        eventProperties: { [name: string]: unknown },
        cssSelector?: string,
        parent: DebugElement &#x3D; this.root
    ): void {
        const nativeElement: HTMLBaseElement &#x3D; parent.query(By.css(cssSelector)).nativeElement;
        // Create keyboard event that bubbles up the chain
        const event &#x3D; new KeyboardEvent(eventType, { bubbles: true });
        // Use &#x60;Object.defineProperty&#x60; in order to be able to set even deprecated, readonly properties like &#x60;which&#x60;
        Object.keys(eventProperties).forEach((key) &#x3D;&gt; {
            Object.defineProperty(event, key, { value: eventProperties[key] });
        });
        nativeElement.dispatchEvent(event);
        this.detectChanges();
    }

    /**
     * Sets the value of an input element or textarea element
     * @param value the value that the element should display
     * @param cssSelector Pass this in if you want trigger the event on a specific element.
     *        If not passed in, the event will be triggered on the entire node
     * @param parent the parent element for which to search for the {@param cssSelector} within. Defaults to root if not provided.
     */
    protected setInputValue(value: string | number, cssSelector?: string, parent: DebugElement &#x3D; this.root): void {
        const nativeElement: HTMLInputElement | HTMLTextAreaElement &#x3D; parent.query(By.css(cssSelector)).nativeElement;
        nativeElement.value &#x3D; String(value);
        nativeElement.dispatchEvent(new Event(&#x27;input&#x27;));
        this.detectChanges();
    }

    /**
     * Returns text content of this widget
     * If the element cannot be found, gives empty string.
     * @param cssSelector Pass this in if you want to retrieve text for a specific element within this widget.
     * @param parent Where to start the search; defaults to the root of this component
     */

    protected getText(cssSelector: string, parent: DebugElement &#x3D; this.root): string {
        const element &#x3D; this.findElement(cssSelector, parent);
        return element ? this.getNodeText(element) : &#x27;&#x27;;
    }

    /**
     * Same as {@link getText} but return the text for all matching nodes
     */
    protected getTexts(cssSelector: string): string[] {
        return this.findElements(cssSelector).map((el) &#x3D;&gt; this.getNodeText(el));
    }

    protected getNodeText(el: DebugElement): string {
        // The || &#x27;&#x27; is because textContent could technically be null when passed in the document
        // element object. We know that cannot be pased in here, so we ignore it for coverage
        // but we still need the line there to make strictNullChecks work
        return el.nativeElement.textContent.trim() || /* istanbul ignore next */ &#x27;&#x27;;
    }
}

/**
 * Subclasses should implement the FindableWidget interface so they can be found with {@link WidgetFinder}
 *
 * ## Note
 * This is done by creating a static property &#x60;tagName&#x60;on your subclass, not a regular instance, since this
 * interface represents a constructor for a {@link WidgetObject}, not an instance.
 */
export interface FindableWidget&lt;T&gt; extends Type&lt;T&gt; {
    tagName: string;
}

/**
 * Arguments for {@link WidgetFinder#findWidgets} and {@link WidgetFinder#find}
 */
export interface FindParams&lt;T&gt; {
    /**
     * The constructor of the widget to be found
     */
    woConstructor: T;
    /**
     * If provided, search starts from this container. It defaults to the fixture&#x27;s root debugElement
     */
    ancestor?: DebugElement;
    /**
     * Optional CSS class name that can be used when there could be multiple instances of the object within the
     * fixture tree
     */
    className?: string;
}

/**
 * @deprecated Finds instances that implement {@link FindableWidget}
 * H is the host component&#x27;s type. This finder is only for old unit tests.
 * Please use AngularWidgetObjectFinder instead.
 */
export class WidgetFinder&lt;H &#x3D; unknown&gt; {
    /**
     * We don&#x27;t care or could possibly know the type of fixture
     */
    private fixture: ComponentFixture&lt;H&gt;;

    /**
     * If you need direct access to manipulate the host
     */
    public hostComponent: H;

    /**
     * @param componentConstructor The host component to be created as the root of the tests&#x27;s fixture
     */
    constructor(componentConstructor: Type&lt;H&gt;) {
        this.fixture &#x3D; TestBed.createComponent(componentConstructor);
        this.hostComponent &#x3D; this.fixture.componentInstance;
    }

    /**
     * Finds widgets within a fixture
     * @return A Potentially empty list of widgets matching the given specs
     */
    public findWidgets&lt;C, T extends FindableWidget&lt;C&gt;&gt;(
        params: FindParams&lt;T&gt; | T,
        parent?: DebugElement
    ): InstanceType&lt;T&gt;[] {
        const defaults &#x3D; { ancestor: this.fixture.debugElement, className: &#x27;&#x27; };
        const { woConstructor, ancestor, className } &#x3D; isFindParamsObject(params)
            ? { ...defaults, ...params }
            : { ...defaults, woConstructor: params };

        let query &#x3D; woConstructor.tagName;
        if (className) {
            query +&#x3D; &#x60;.${className}&#x60;;
        }
        const componentRoots &#x3D; (parent ? parent : ancestor).queryAll(By.css(query));
        const widgets &#x3D; componentRoots.map(
            // Typescript is not able to infer it correctly as the subclass but we know for sure
            (root) &#x3D;&gt; new woConstructor(this.fixture, root, root.componentInstance) as InstanceType&lt;T&gt;
        );
        return widgets;
    }

    /**
     * Finds a single widget object
     * @throws An error if the widget is not found or if there are multiple instances
     */
    public find&lt;C, T extends FindableWidget&lt;C&gt;&gt;(params: FindParams&lt;T&gt; | T): InstanceType&lt;T&gt; {
        const widgets &#x3D; this.findWidgets(params);
        const tagName &#x3D; isFindParamsObject(params) ? params.woConstructor.tagName : params.tagName;
        if (widgets.length &#x3D;&#x3D;&#x3D; 0) {
            throw Error(&#x60;Did not find a &lt;${tagName}&gt;&#x60;);
        }
        if (widgets.length &gt; 1) {
            throw Error(&#x60;Expected to find a single &lt;${tagName}&gt; but found ${widgets.length}&#x60;);
        }
        return widgets[0] as InstanceType&lt;T&gt;;
    }

    public detectChanges(): void {
        this.fixture.detectChanges();
    }
}

export function isFindParamsObject&lt;T&gt;(params: FindParams&lt;T&gt; | T): params is FindParams&lt;T&gt; {
    return !!(params as FindParams&lt;T&gt;).woConstructor;
}
/**
 * Can be used in tests that use &#x60;this&#x60; to share a finder with before/AfterEach instead of leaky closures
 */
export interface HasFinder&lt;T &#x3D; unknown&gt; {
    finder: WidgetFinder&lt;T&gt;;
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'HasFinder.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
