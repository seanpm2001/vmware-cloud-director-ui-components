<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>vmware-cloud-director-ui-components documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">vmware-cloud-director-ui-components documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>ActionItemInternal</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/components/src/action-menu/action-menu.component.ts</code>
        </p>

            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>We internally convert the callbacks to booleans to avoid calling the callbacks all the time from template. However, we don&#39;t want to
allow callers to assign boolean variables to availability as there is no way to know when those variables can get updated from outside.</p>

            </p>

            <p class="comment">
                <h3>Extends</h3>
            </p>
            <p class="comment">
                        <code><a href="../interfaces/BaseActionItem.html" target="_self" >BaseActionItem</a></code>
            </p>

        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#actionType">actionType</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#availability">availability</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#lastAvailabilityValue">lastAvailabilityValue</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="actionType"></a>
                                        <span class="name"><b>actionType</b><a href="#actionType"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>actionType:         <code><a href="../miscellaneous/enumerations.html#ActionType" target="_self" >ActionType</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../miscellaneous/enumerations.html#ActionType" target="_self" >ActionType</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Used for determining where in the action menu this action gets displayed</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="availability"></a>
                                        <span class="name"><b>availability</b><a href="#availability"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>availability:     <code>Observable&lt;boolean&gt; | boolean</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>Observable&lt;boolean&gt; | boolean</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Condition whether or not the action is available.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="lastAvailabilityValue"></a>
                                        <span class="name"><b>lastAvailabilityValue</b><a href="#lastAvailabilityValue"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>lastAvailabilityValue:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Stores the last emitted value from availability observable of an action item. Used to show or hide that action item.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, EventEmitter, Input, OnDestroy, Output, TrackByFunction } from &#x27;@angular/core&#x27;;
import { isObservable, Observable, Subscription } from &#x27;rxjs&#x27;;
import {
    ActionDisplayConfig,
    ActionItem,
    ActionStyling,
    ActionType,
    BaseActionItem,
    TextIcon,
} from &#x27;../common/interfaces&#x27;;
import { lastAvailabilityValue } from &#x27;../constants&#x27;;
import { CommonUtil } from &#x27;../utils&#x27;;

/**
 * To add default values to configs if they are not provided by the caller in the input config
 */
export function getDefaultActionDisplayConfig(cfg: ActionDisplayConfig &#x3D; {}): ActionDisplayConfig {
    const defaults &#x3D; {
        contextual: {
            styling: ActionStyling.INLINE,
            buttonContents: TextIcon.TEXT,
        },
        staticActionStyling: ActionStyling.INLINE,
    };
    return {
        contextual: { ...defaults.contextual, ...cfg.contextual },
        staticActionStyling: cfg.staticActionStyling || defaults.staticActionStyling,
    };
}

/**
 * We internally convert the callbacks to booleans to avoid calling the callbacks all the time from template. However, we don&#x27;t want to
 * allow callers to assign boolean variables to availability as there is no way to know when those variables can get updated from outside.
 */
interface ActionItemInternal&lt;R, T&gt; extends BaseActionItem&lt;R, T&gt; {
    /**
     * Used for determining where in the action menu this action gets displayed
     */
    actionType?: ActionType;
    /**
     * Condition whether or not the action is available.
     */
    availability?: Observable&lt;boolean&gt; | boolean;
    /**
     * Stores the last emitted value from availability observable of an action item. Used to show or hide that action item.
     */
    [lastAvailabilityValue]?: boolean;
}

/**
 * Renders actions in screens containing grids, cards and details container screens
 * R is the type of selected entity on which the action will be performed
 * T is the type of custom data passed to action handler methods
 */
@Component({
    selector: &#x27;vcd-action-menu&#x27;,
    templateUrl: &#x27;./action-menu.component.html&#x27;,
    styleUrls: [&#x27;./action-menu.component.scss&#x27;],
})
export class ActionMenuComponent&lt;R, T&gt; implements OnDestroy {
    /**
     * To access the private key lastAvailabilityValue from the template
     */
    lastAvailabilityValue &#x3D; lastAvailabilityValue;
    /**
     * Stores all the subscriptions of availability observables. Used for un-subscribing from subscriptions that are not needed
     */
    lastAvailabilitySubscriptions: Subscription[] &#x3D; [];
    /**
     * Emits when the actions have been updated.
     * Then one can get the actual actions from {@link staticActions} and {@link contextualActions} property.
     */
    @Output() actionsUpdate: EventEmitter&lt;void&gt; &#x3D; new EventEmitter();

    /**
     * List of actions containing both static and contextual that are given by the calling component
     */
    @Input() set actions(actions: ActionItem&lt;R, T&gt;[]) {
        actions &#x3D; actions || [];
        // Shallow equal does the job for most of the cases and currently saves a lot of calculations
        if (this.isShallowEqual(actions, this._originalActions)) {
            return;
        }
        this._originalActions &#x3D; actions;
        this.refreshActions(actions);
    }

    /**
     * Original actions as provided to this component without any modifications
     */
    private _originalActions: ActionItem&lt;R, T&gt;[] &#x3D; [];

    /**
     * Access modifier is public in order to access this property in unit tests
     */
    _actions: ActionItemInternal&lt;R, T&gt;[] &#x3D; [];

    private _actionDisplayConfig: ActionDisplayConfig &#x3D; getDefaultActionDisplayConfig();
    /**
     * Display configuration of both static and contextual actions
     * If null or undefined is passed, default config {@link _actionDisplayConfig} is used
     */
    @Input() set actionDisplayConfig(config: ActionDisplayConfig) {
        this._actionDisplayConfig &#x3D; getDefaultActionDisplayConfig(config || {});
        const buttonContents &#x3D; this.actionDisplayConfig.contextual.buttonContents;
        this.shouldShowIcon &#x3D; (TextIcon.ICON &amp; buttonContents) &#x3D;&#x3D;&#x3D; TextIcon.ICON;
        this.shouldShowText &#x3D; (TextIcon.TEXT &amp; buttonContents) &#x3D;&#x3D;&#x3D; TextIcon.TEXT;
        this.shouldShowTooltip &#x3D; buttonContents &#x3D;&#x3D;&#x3D; TextIcon.ICON;
        this.updateActionListsAndDisplayFlags();
    }
    get actionDisplayConfig(): ActionDisplayConfig {
        return this._actionDisplayConfig;
    }

    /**
     * Copy of actions passed with their availability call backs. This is because, when the selected entities get updated, we need to use
     * those CBs to calculate the availability again
     */
    private actionsWithAvailabilityCb: ActionItem&lt;R, T&gt;[] &#x3D; [];

    /**
     * When there are no nested actions and if all of the contextual actions are marked to be featured, there is no need to show
     * the contextual actions dropdown in the inline actions container
     */
    shouldDisplayContextualActionsDropdownInline &#x3D; false;

    /**
     * Text Content of the action menu dropdown trigger button. Used when {@link #actionDisplayConfig} styling is
     * {@link ActionStyling.DROPDOWN}
     */
    @Input() dropdownTriggerBtnText: string &#x3D; null;

    /**
     * Text Content of the action menu dropdown trigger button inside the .inline-actions-container
     */
    inlineDropdownTriggerBtnText &#x3D; &#x27;vcd.cc.action.menu.actions&#x27;;

    /**
     * Icon of the action menu dropdown trigger button. Used when {@link #actionDisplayConfig} styling is
     * {@link ActionStyling.DROPDOWN}
     */
    @Input() dropdownTriggerBtnIcon: string &#x3D; null;

    /**
     * Used for disabling the menu bar or menu dropdown
     */
    @Input() disabled: boolean;

    /**
     * The direction with respect to the root dropdown trigger button in which the root drop down should open
     * {@link DropdownComponent.dropdownPosition}
     */
    @Input() dropdownPosition: string;

    /**
     * The direction in which the nested drop downs open. {@link DropdownComponent.nestedDropdownPosition}
     */
    @Input() nestedDropdownPosition &#x3D; &#x27;right-top&#x27;;

    /**
     * If a icon should be displayed inside contextual buttons
     */
    shouldShowIcon: boolean &#x3D; (TextIcon.ICON &amp; this.actionDisplayConfig.contextual.buttonContents) &#x3D;&#x3D;&#x3D; TextIcon.ICON;

    /**
     * If a text should be displayed inside contextual buttons
     */
    shouldShowText: boolean &#x3D; (TextIcon.TEXT &amp; this.actionDisplayConfig.contextual.buttonContents) &#x3D;&#x3D;&#x3D; TextIcon.TEXT;

    /**
     * If the contextual buttons with icons should have a tooltip
     */
    shouldShowTooltip: boolean &#x3D; this.actionDisplayConfig.contextual.buttonContents &#x3D;&#x3D;&#x3D; TextIcon.ICON;

    /**
     * Used in the html template
     */
    actionStyling &#x3D; ActionStyling;

    /**
     * List of actions that are marked as {@link ActionType.STATIC_FEATURED} only
     */
    staticFeaturedActions: ActionItemInternal&lt;R, T&gt;[];

    /**
     * Actions that depend on selected entities and belong to main menu list. The returned list length is less than or
     * equal to the configured featured count in {@link actionDisplayConfig}
     */
    contextualFeaturedActions: ActionItemInternal&lt;R, T&gt;[] &#x3D; [];

    /**
     * All the actions that depend on selected entities
     */
    contextualActions: ActionItemInternal&lt;R, T&gt;[] &#x3D; [];

    /**
     * List containing all the static actions. It has static featured actions in the beginning of the list followed by
     * non-featured static actions as children of grouped action called &#x27;vcd.cc.action.menu.all.actions&#x27;
     */
    staticDropdownActions: ActionItemInternal&lt;R, T&gt;[] | object;

    /**
     * List of only the actions that are marked as {@link ActionType.STATIC}
     */
    staticActions: ActionItemInternal&lt;R, T&gt;[];

    /**
     * To show or hide the container elements containing inline and also dropdown actions
     */
    shouldDisplayActionsInline: boolean;

    /**
     * To show or hide {@link ActionType.CONTEXTUAL} and {@link ActionType.CONTEXTUAL_FEATURED} actions in inline
     * action container
     */
    shouldDisplayContextualActionsInline: boolean;

    /**
     * To show or hide {@link ActionType.STATIC_FEATURED} actions in inline action container
     */
    shouldDisplayStaticFeaturedActionsInline: boolean;

    /**
     * To show or hide {@link ActionType.STATIC} actions in inline action container
     */
    shouldDisplayStaticActionsInline: boolean;

    /**
     * To show or hide {@link ActionType.STATIC_FEATURED} and {@link ActionType.STATIC} actions in a dropdown
     */
    shouldDisplayStaticAndStaticFeaturedActionsDropdown: boolean;

    /**
     * To show or hide {@link ActionType.CONTEXTUAL} and {@link ActionType.CONTEXTUAL_FEATURED} actions in a dropdown
     */
    shouldDisplayContextualActionsDropdown: boolean;

    /**
     * Used for deciding if the availability has to be passed through an Async pipe in the template
     */
    isObservable &#x3D; isObservable;

    /**
     * The list of entities selected on which contextualActions are performed. As they are also used for calculating the
     * availability of actions, action lists are updated when the input is updated
     * @param val Is an array in case of batch selection and is a single item for example in the case of data grids with single selection
     */
    @Input() set selectedEntities(val: R[] | R) {
        if (!Array.isArray(val)) {
            val &#x3D; val ? [val] : [];
        }
        // Shallow equal does the job for most of the cases and currently saves a lot of calculations
        if (this.isShallowEqual(val, this._selectedEntities)) {
            return;
        }
        this._selectedEntities &#x3D; val;
        this.updateDisplayedActions();
    }
    private _selectedEntities: R[] &#x3D; [];

    /**
     * Returns the selected entities
     * Note: This is not a getter because its matching setter can accept an array or a single item but this method always returns an array.
     */
    getSelectedEntities(): R[] {
        return this._selectedEntities;
    }

    /**
     * The visibility of actions is dependent on their availability call back responses and in VCD application, some of the actions
     * availability call back response is dependent on closure variables. However, we don&#x27;t call those call backs every time those closure
     * variables are updated, for example by asynchronous requests. This has a side effect of actions visibility not getting updated when
     * those closure variables are updated. So, this convenience method is to make it clear for the user that such side effect exists and
     * this method will re-trigger the availability call backs of actions
     */
    updateDisplayedActions(): void {
        this.clearLastAvailabilitySubs();
        this._actions &#x3D; this.changeAvailabilityCallbacks(this.actionsWithAvailabilityCb);
        this.updateActionListsAndDisplayFlags();
    }

    private refreshActions(actions: ActionItem&lt;R, T&gt;[]): void {
        if (!actions) {
            return;
        }
        const hasNestedActions &#x3D; actions.some((action) &#x3D;&gt; action.children?.length &gt; 0);
        const shouldMarkUnmarkedActionsAsContextual &#x3D;
            hasNestedActions ||
            this.getFlattenedActionList(actions, ActionType.CONTEXTUAL_FEATURED).some(
                (action) &#x3D;&gt; action.actionType &amp;&amp; action.actionType &#x3D;&#x3D;&#x3D; ActionType.CONTEXTUAL_FEATURED
            );
        this.actionsWithAvailabilityCb &#x3D; this.markUnmarkedActions(actions, shouldMarkUnmarkedActionsAsContextual);
        this.shouldDisplayContextualActionsDropdownInline &#x3D;
            hasNestedActions ||
            this.actionsWithAvailabilityCb.some((action) &#x3D;&gt; action.actionType &#x3D;&#x3D;&#x3D; ActionType.CONTEXTUAL);
        this.updateDisplayedActions();
    }

    private markUnmarkedActions(actions: ActionItem&lt;R, T&gt;[], shouldMarkUnmarkedActionsAsContextual: boolean) {
        return actions.map((action) &#x3D;&gt; {
            const actionCopy &#x3D; { ...action };
            if (!actionCopy.actionType) {
                actionCopy.actionType &#x3D; shouldMarkUnmarkedActionsAsContextual
                    ? ActionType.CONTEXTUAL
                    : ActionType.CONTEXTUAL_FEATURED;
            }
            if (action.children) {
                action.children &#x3D; this.markUnmarkedActions(action.children, shouldMarkUnmarkedActionsAsContextual);
            }
            return actionCopy;
        });
    }

    /**
     * Executes the availability call backs and updates them to booleans. Also, Subscribes to availability of actions that are observables
     * and adds a magic property called {@link lastAvailabilityValue} that stores the last emitted value from those observables.
     */
    private changeAvailabilityCallbacks(actions) {
        return actions.map((action) &#x3D;&gt; {
            const actionCopy: ActionItemInternal&lt;R, T&gt; &#x3D; { ...action };
            if (action.availability instanceof Observable) {
                this.lastAvailabilitySubscriptions.push(
                    action.availability.subscribe((value) &#x3D;&gt; {
                        actionCopy[lastAvailabilityValue] &#x3D; value;
                    })
                );
            } else {
                actionCopy.availability &#x3D; this.isActionAvailable(action);
            }
            if (actionCopy.children) {
                actionCopy.children &#x3D; this.changeAvailabilityCallbacks(action.children);
            }
            return actionCopy;
        });
    }

    private clearLastAvailabilitySubs() {
        this.lastAvailabilitySubscriptions.forEach((sub) &#x3D;&gt; sub.unsubscribe());
        this.lastAvailabilitySubscriptions.length &#x3D; 0;
    }

    private updateActionListsAndDisplayFlags(): void {
        this.staticActions &#x3D; this.getStaticActions();
        this.staticFeaturedActions &#x3D; this.getStaticFeaturedActions();
        this.contextualFeaturedActions &#x3D; this.getContextualFeaturedActions();
        this.contextualActions &#x3D; this.getContextualActions();
        this.staticDropdownActions &#x3D; this.getStaticDropdownActions();
        this.updateActionDisplayFlags();
        // Emit an update that actions have been changed
        this.actionsUpdate.emit();
    }

    private updateActionDisplayFlags(): void {
        this.shouldDisplayActionsInline &#x3D; this.getShouldDisplayActionsInline();
        this.shouldDisplayContextualActionsInline &#x3D; this.shouldDisplayContextualActions(this.actionStyling.INLINE);
        this.shouldDisplayStaticFeaturedActionsInline &#x3D; this.shouldDisplayStaticFeaturedActions(
            this.actionStyling.INLINE
        );
        this.shouldDisplayStaticActionsInline &#x3D; this.shouldDisplayStaticActions(this.actionStyling.INLINE);
        this.shouldDisplayStaticAndStaticFeaturedActionsDropdown &#x3D;
            this.shouldDisplayStaticActions(this.actionStyling.DROPDOWN) ||
            this.shouldDisplayStaticFeaturedActions(this.actionStyling.DROPDOWN);
        this.shouldDisplayContextualActionsDropdown &#x3D; this.shouldDisplayContextualActions(this.actionStyling.DROPDOWN);
    }

    /**
     * Used only for actions that don&#x27;t have their availability as Observables.
     * An action whose availability is false but has the disabled state set to true is still shown on the screen in
     * disabled mode
     */
    private isActionAvailable(action: ActionItem&lt;R, T&gt; | ActionItemInternal&lt;R, T&gt;): boolean {
        let isActionAvailable &#x3D; true;
        if (action.availability &#x3D;&#x3D; null) {
            isActionAvailable &#x3D; true;
        }
        if (typeof action.availability &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27;) {
            isActionAvailable &#x3D; action.availability;
        }
        if (CommonUtil.isFunction(action.availability)) {
            isActionAvailable &#x3D;
                this.getSelectedEntities().length &gt; 0 &amp;&amp; action.availability(this.getSelectedEntities());
        }
        return isActionAvailable || this.isActionDisabled(action);
    }

    private getStaticFeaturedActions(): ActionItemInternal&lt;R, T&gt;[] {
        return this._actions.filter((action) &#x3D;&gt; action.actionType &#x3D;&#x3D;&#x3D; ActionType.STATIC_FEATURED);
    }

    private getContextualFeaturedActions(): ActionItemInternal&lt;R, T&gt;[] {
        if (!this.getSelectedEntities().length) {
            return [];
        }
        const flattenedFeaturedActionList &#x3D; this.getFlattenedActionList(this._actions, ActionType.CONTEXTUAL_FEATURED);
        const availableFeaturedActions &#x3D; flattenedFeaturedActionList.filter(
            (action) &#x3D;&gt; action[lastAvailabilityValue] || action.availability
        );
        const featuredCount &#x3D;
            this.actionDisplayConfig.contextual.styling &#x3D;&#x3D;&#x3D; ActionStyling.INLINE &amp;&amp;
            this.actionDisplayConfig.contextual.featuredCount;
        return featuredCount ? availableFeaturedActions.slice(0, featuredCount) : availableFeaturedActions;
    }

    private getStaticActions(): ActionItemInternal&lt;R, T&gt;[] {
        return this._actions.filter((action) &#x3D;&gt; action.actionType &#x3D;&#x3D;&#x3D; ActionType.STATIC);
    }

    private getStaticDropdownActions(): ActionItemInternal&lt;R, T&gt;[] | object {
        return this.staticFeaturedActions.concat([
            {
                textKey: &#x27;vcd.cc.action.menu.other.actions&#x27;,
                children: (this.staticActions as any) as ActionItem&lt;R, T&gt;[],
            },
        ]);
    }

    private getContextualActions(): ActionItemInternal&lt;R, T&gt;[] {
        if (!this.getSelectedEntities().length) {
            return [];
        }
        return this._actions.filter(
            (action) &#x3D;&gt;
                !action.actionType ||
                (action.actionType !&#x3D;&#x3D; ActionType.STATIC_FEATURED &amp;&amp; action.actionType !&#x3D;&#x3D; ActionType.STATIC)
        );
    }

    /**
     * Extracts the nested actions that are marked as featured and returns them as part of a flat list
     */
    private getFlattenedActionList(
        actions: ActionItemInternal&lt;R, T&gt;[] | ActionItem&lt;R, T&gt;[],
        actionType: ActionType
    ): ActionItemInternal&lt;R, T&gt;[] {
        let featuredActions: ActionItemInternal&lt;R, T&gt;[] &#x3D; [];
        actions.forEach((action) &#x3D;&gt; {
            if (action.children &amp;&amp; action.children.length) {
                featuredActions &#x3D; featuredActions.concat(this.getFlattenedActionList(action.children, actionType));
            } else if (action.actionType &#x3D;&#x3D;&#x3D; actionType) {
                featuredActions.push(action);
            }
        });
        return featuredActions;
    }

    /**
     * Action click handler
     */
    runActionHandler(action: ActionItem&lt;R, T&gt;): void {
        if (this.isActionDisabled(action)) {
            return;
        }
        if (action.handler) {
            action.handler(this.getSelectedEntities(), action.handlerData);
        }
    }

    /**
     * To disable a displayed action
     */
    isActionDisabled(action: ActionItem&lt;R, T&gt; | ActionItemInternal&lt;R, T&gt;): boolean {
        if (action.disabled &#x3D;&#x3D; null) {
            return false;
        }
        if (CommonUtil.isFunction(action.disabled)) {
            return action.disabled(this.getSelectedEntities());
        }
        return action.disabled;
    }

    /**
     * Used as {@link ngForTrackBy} input value when iterating over action lists {@link DropdownComponent.trackByFunction}
     * Without this method as input for ngForTrackBy, the dropdown gets rendered off screen
     */
    actionsTrackBy: TrackByFunction&lt;ActionItem&lt;R, T&gt;&gt; &#x3D; (index: number, item: ActionItem&lt;R, T&gt;): string &#x3D;&gt; {
        return item.textKey;
    };

    private getShouldDisplayActionsInline(): boolean {
        return (
            this.shouldDisplayStaticFeaturedActions(ActionStyling.INLINE) ||
            this.shouldDisplayStaticActions(ActionStyling.INLINE) ||
            this.shouldDisplayContextualActions(ActionStyling.INLINE)
        );
    }

    private shouldDisplayStaticFeaturedActions(style: ActionStyling): boolean {
        return (
            this.staticFeaturedActions &amp;&amp;
            this.staticFeaturedActions.length &amp;&amp;
            this.actionDisplayConfig.staticActionStyling &#x3D;&#x3D;&#x3D; style
        );
    }

    private shouldDisplayStaticActions(style: ActionStyling): boolean {
        return (
            this.staticActions &amp;&amp; this.staticActions.length &amp;&amp; this.actionDisplayConfig.staticActionStyling &#x3D;&#x3D;&#x3D; style
        );
    }

    private shouldDisplayContextualActions(style: ActionStyling): boolean {
        return (
            this.getSelectedEntities().length &amp;&amp;
            this.contextualActions.length &amp;&amp;
            this.actionDisplayConfig.contextual.styling &#x3D;&#x3D;&#x3D; style
        );
    }

    /**
     * Performance optimization function to do shallow comparison of two arrays.
     * @param arr1
     * @param arr2
     */
    private isShallowEqual(arr1: unknown[], arr2: unknown[]): boolean {
        if (arr1 &#x3D;&#x3D;&#x3D; arr2) {
            return true;
        }
        if ((!arr1 &amp;&amp; arr2) || (arr1 &amp;&amp; !arr2)) {
            return false;
        }
        if (arr1.length !&#x3D;&#x3D; arr2.length) {
            return false;
        }
        if (arr1.length &#x3D;&#x3D;&#x3D; 0 &amp;&amp; arr2.length &#x3D;&#x3D;&#x3D; 0) {
            return true;
        }
        return arr1.every((item, index) &#x3D;&gt; item &#x3D;&#x3D;&#x3D; arr2[index]);
    }

    ngOnDestroy(): void {
        this.clearLastAvailabilitySubs();
    }
}
</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'ActionItemInternal.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
